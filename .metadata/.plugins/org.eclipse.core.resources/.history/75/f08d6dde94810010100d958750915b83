/*
 * main.c — Application using native FreeRTOS API (no CMSIS-OS)
 * - Blink LED PC13
 * - Logger in ra tick & tick_hz
 * - uart_cmd_task nghe UART1 (ESP32). Nếu nhận 'B' => set BOOT_REQ rồi reset
 * - Producer/Consumer queue demo
 *
 * VN: Không dùng SysTick_Handler tự viết. FreeRTOS quản lý SysTick.
 */

#include "app.h"
#include <stdio.h>
#include <string.h>

/* FreeRTOS */
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"


static void clock_init(void) {
    /* Enable HSE */
    RCC->CR |= RCC_CR_HSEON;
    while (!(RCC->CR & RCC_CR_HSERDY)) { }

    /* Flash wait states = 2, prefetch on */
    FLASH->ACR |= FLASH_ACR_PRFTBE;
    FLASH->ACR &= ~FLASH_ACR_LATENCY;
    FLASH->ACR |= FLASH_ACR_LATENCY_2;

    /* PLL: source HSE, mul x9 => 72MHz */
    RCC->CFGR &= ~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL);
    RCC->CFGR |= RCC_CFGR_PLLSRC;              /* HSE as PLL source */
    RCC->CFGR |= RCC_CFGR_PLLMULL9;

    /* APB prescalers: AHB=1, APB2=1, APB1=2 (36MHz) */
    RCC->CFGR &= ~(RCC_CFGR_HPRE | RCC_CFGR_PPRE1 | RCC_CFGR_PPRE2);
    RCC->CFGR |= (0<<4); /* AHB=1 */
    RCC->CFGR |= RCC_CFGR_PPRE1_DIV2; /* APB1=36MHz */
    RCC->CFGR |= (0<<11); /* APB2=1 */

    /* Enable PLL */
    RCC->CR |= RCC_CR_PLLON;
    while (!(RCC->CR & RCC_CR_PLLRDY)) { }

    /* Switch SYSCLK to PLL */
    RCC->CFGR &= ~RCC_CFGR_SW;
    RCC->CFGR |= RCC_CFGR_SW_PLL;
    while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_PLL) { }
}

void System_Init(void) {
    /* Reset RCC registers to defaults (optional minimal) */
    RCC->CR |= RCC_CR_HSION;
    RCC->CFGR = 0x00000000;
    RCC->CR &= ~(RCC_CR_HSEON | RCC_CR_PLLON);
    RCC->CIR = 0x00000000;

    clock_init();
    SystemCoreClock = 72000000UL;
}
/* ====== UART Low-level ====== */
static void uart_gpio_init(void) {
    /* Clocks */
    RCC->APB2ENR |= RCC_APB2ENR_IOPAEN | RCC_APB2ENR_IOPCEN | RCC_APB2ENR_AFIOEN | RCC_APB2ENR_USART1EN;
    RCC->APB1ENR |= RCC_APB1ENR_USART3EN;
    RCC->APB2ENR |= RCC_APB2ENR_IOPBEN;

    /* LED PC13: output push-pull 10MHz */
    GPIOC->CRH &= ~(0xF << ((13-8)*4));
    GPIOC->CRH |=  (0x1 << ((13-8)*4));

    /* PA9 TX1 (AF PP), PA10 RX1 (input floating) */
    uint32_t crh = GPIOA->CRH;
    crh &= ~((0xF) << ((9-8)*4));
    crh |=  ((0xB) << ((9-8)*4));
    crh &= ~((0xF) << ((10-8)*4));
    crh |=  ((0x4) << ((10-8)*4));
    GPIOA->CRH = crh;

    /* PB10 TX3 (AF PP), PB11 RX3 (input floating) */
    uint32_t crh_b = GPIOB->CRH;
    crh_b &= ~((0xF) << ((10-8)*4));
    crh_b |=  ((0xB) << ((10-8)*4));
    crh_b &= ~((0xF) << ((11-8)*4));
    crh_b |=  ((0x4) << ((11-8)*4));
    GPIOB->CRH = crh_b;
}

static void uart_setup(USART_TypeDef* U, uint32_t pclk, uint32_t baud, int enable_rx) {
    U->CR1 = 0; U->CR2 = 0; U->CR3 = 0;
    uint32_t div_mantissa = pclk / (16U * baud);
    uint32_t div_frac     = ((pclk % (16U * baud)) * 16U) / (16U * baud);
    U->BRR = (div_mantissa << 4) | (div_frac & 0xF);
    U->CR1 = USART_CR1_TE | USART_CR1_UE;
    if (enable_rx) U->CR1 |= USART_CR1_RE;
}

void uart_init(void) {
    uart_gpio_init();
    uart_setup(USART1, SYS_CORE_CLOCK_HZ,   UART1_BAUD, 1);
    uart_setup(USART3, SYS_CORE_CLOCK_HZ/2, UART3_BAUD, 0); /* TX only */
}

void uart1_write_str(const char* s) {
    while (*s) {
        while (!(USART1->SR & USART_SR_TXE)) {}
        USART1->DR = *s++;
    }
}

int uart1_read_byte(uint8_t* out, uint32_t timeout_ms) {
    TickType_t t0 = xTaskGetTickCount();
    const TickType_t to_ticks = pdMS_TO_TICKS(timeout_ms);
    for (;;) {
        if (USART1->SR & USART_SR_RXNE) {
            *out = (uint8_t)USART1->DR;
            return 0;
        }
        if ((xTaskGetTickCount() - t0) >= to_ticks) return -1;
        vTaskDelay(pdMS_TO_TICKS(1));
    }
}

static void uart3_write_byte(uint8_t b) {
    while (!(USART3->SR & USART_SR_TXE)) {}
    USART3->DR = b;
}
void uart3_write_str(const char* s) {
    while (*s) uart3_write_byte((uint8_t)*s++);
}

void log_printf(const char* fmt, ...) {
    char buf[160];
    va_list ap; va_start(ap, fmt);
    int n = vsnprintf(buf, sizeof(buf), fmt, ap);
    va_end(ap);
    if (n > 0) uart3_write_str(buf);
}

/* ====== Metadata helper ====== */
void meta_request_boot(void) {
    bl_meta_t m;
    memcpy(&m, (void*)META_BASE, sizeof(m));
    if (m.magic != META_MAGIC) m.magic = META_MAGIC;
    m.flags |= MF_BOOT_REQ;

    /* Erase + program 1 page (1KB) chứa metadata */
    FLASH->KEYR = 0x45670123; FLASH->KEYR = 0xCDEF89AB;
    /* Erase page */
    FLASH->CR |= FLASH_CR_PER; FLASH->AR = META_BASE; FLASH->CR |= FLASH_CR_STRT;
    while (FLASH->SR & FLASH_SR_BSY) {}
    FLASH->CR &= ~FLASH_CR_PER;
    /* Program */
    FLASH->CR |= FLASH_CR_PG;
    uint16_t* src = (uint16_t*)&m;
    uint16_t* dst = (uint16_t*)META_BASE;
    for (size_t i = 0; i < sizeof(m)/2; i++) {
        dst[i] = src[i];
        while (FLASH->SR & FLASH_SR_BSY) {}
    }
    FLASH->CR &= ~FLASH_CR_PG;
    FLASH->CR |= FLASH_CR_LOCK;
}

/* ====== Tasks ====== */
static QueueHandle_t qh = NULL;

static void blink_task(void* arg) {
    (void)arg;
    for (;;) {
        LED_PORT->ODR ^= (1<<LED_PIN);
        vTaskDelay(pdMS_TO_TICKS(500));
    }
}

static void logger_task(void* arg) {
    (void)arg;
    for (;;) {
        uint32_t tick = (uint32_t)xTaskGetTickCount();
        unsigned hz   = (unsigned)configTICK_RATE_HZ; /* từ FreeRTOSConfig.h */
        log_printf("[APP] tick=%lu tick_hz=%u\n", (unsigned long)tick, hz);
        vTaskDelay(pdMS_TO_TICKS(1000));
    }
}

static void uart_cmd_task(void* arg) {
    (void)arg;
    for (;;) {
        uint8_t b;
        if (uart1_read_byte(&b, 100) == 0) {
            if (b == 'B') {
                log_printf("[APP] BOOT cmd -> set BOOT_REQ & reset\n");
                meta_request_boot();
                NVIC_SystemReset();
            }
        }
        vTaskDelay(pdMS_TO_TICKS(10));
    }
}

static void producer_task(void* arg) {
    (void)arg;
    uint32_t i = 0;
    for (;;) {
        xQueueSend(qh, &i, portMAX_DELAY);
        i++;
        vTaskDelay(pdMS_TO_TICKS(200));
    }
}

static void consumer_task(void* arg) {
    (void)arg;
    uint32_t v;
    for (;;) {
        if (xQueueReceive(qh, &v, portMAX_DELAY) == pdTRUE) {
            log_printf("[Q] got %lu\n", (unsigned long)v);
        }
    }
}

/* ====== main() ====== */
int main(void) {
    System_Init();
    uart_init();

    log_printf("[APP v2] FreeRTOS native, VTOR=0x%08lX\n", SCB->VTOR);

    /* Queue */
    qh = xQueueCreate(8, sizeof(uint32_t));

    /* Create tasks — chú ý stack depth tính theo WORD (4 bytes) */
    xTaskCreate(blink_task,   "blink",  128, NULL, tskIDLE_PRIORITY + 1, NULL);
    xTaskCreate(logger_task,  "logger", 256, NULL, tskIDLE_PRIORITY + 1, NULL);
    xTaskCreate(uart_cmd_task,"uart",   256, NULL, tskIDLE_PRIORITY + 2, NULL);
    xTaskCreate(producer_task,"prod",   128, NULL, tskIDLE_PRIORITY + 1, NULL);
    xTaskCreate(consumer_task,"cons",   128, NULL, tskIDLE_PRIORITY + 1, NULL);

    /* Start scheduler */
    vTaskStartScheduler();

    /* Should never reach here */
    for (;;);
}
