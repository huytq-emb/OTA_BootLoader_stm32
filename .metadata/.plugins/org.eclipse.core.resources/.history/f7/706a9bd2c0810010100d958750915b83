/*
 * main.c — Application using native FreeRTOS API (no CMSIS-OS)
 * - Blink LED PC13
 * - Logger in ra tick & tick_hz
 * - uart_cmd_task nghe UART1 (ESP32). Nếu nhận 'B' => set BOOT_REQ rồi reset
 * - Producer/Consumer queue demo
 *
 * VN: Không dùng SysTick_Handler tự viết. FreeRTOS quản lý SysTick.
 */

#include "app.h"
#include <stdio.h>
#include <string.h>

/* FreeRTOS */
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"

static inline void relocate_vtor(void){
    SCB->VTOR = APP_BASE;
    __DSB(); __ISB();  // đảm bảo ghi VTOR có hiệu lực trước khi bật ngắt/tick
}

static void clock_init(void) {
    /* Enable HSE */
    RCC->CR |= RCC_CR_HSEON;
    while (!(RCC->CR & RCC_CR_HSERDY)) { }

    /* Flash wait states = 2, prefetch on */
    FLASH->ACR |= FLASH_ACR_PRFTBE;
    FLASH->ACR &= ~FLASH_ACR_LATENCY;
    FLASH->ACR |= FLASH_ACR_LATENCY_2;

    /* PLL: source HSE, mul x9 => 72MHz */
    RCC->CFGR &= ~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL);
    RCC->CFGR |= RCC_CFGR_PLLSRC;              /* HSE as PLL source */
    RCC->CFGR |= RCC_CFGR_PLLMULL9;

    /* APB prescalers: AHB=1, APB2=1, APB1=2 (36MHz) */
    RCC->CFGR &= ~(RCC_CFGR_HPRE | RCC_CFGR_PPRE1 | RCC_CFGR_PPRE2);
    RCC->CFGR |= (0<<4); /* AHB=1 */
    RCC->CFGR |= RCC_CFGR_PPRE1_DIV2; /* APB1=36MHz */
    RCC->CFGR |= (0<<11); /* APB2=1 */

    /* Enable PLL */
    RCC->CR |= RCC_CR_PLLON;
    while (!(RCC->CR & RCC_CR_PLLRDY)) { }

    /* Switch SYSCLK to PLL */
    RCC->CFGR &= ~RCC_CFGR_SW;
    RCC->CFGR |= RCC_CFGR_SW_PLL;
    while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_PLL) { }
}

void System_Init(void) {
    /* Reset RCC registers to defaults (optional minimal) */
    RCC->CR |= RCC_CR_HSION;
    RCC->CFGR = 0x00000000;
    RCC->CR &= ~(RCC_CR_HSEON | RCC_CR_PLLON);
    RCC->CIR = 0x00000000;

    clock_init();
    SystemCoreClock = 72000000UL;
}
/* ====== UART Low-level ====== */
static void uart_gpio_init(void) {
    /* Clocks */
    RCC->APB2ENR |= RCC_APB2ENR_IOPAEN | RCC_APB2ENR_IOPCEN | RCC_APB2ENR_AFIOEN | RCC_APB2ENR_USART1EN;
    RCC->APB1ENR |= RCC_APB1ENR_USART3EN;
    RCC->APB2ENR |= RCC_APB2ENR_IOPBEN;

    /* LED PC13: output push-pull 10MHz */
    GPIOC->CRH &= ~(0xF << ((13-8)*4));
    GPIOC->CRH |=  (0x1 << ((13-8)*4));

    /* PA9 TX1 (AF PP), PA10 RX1 (input floating) */
    uint32_t crh = GPIOA->CRH;
    crh &= ~((0xF) << ((9-8)*4));
    crh |=  ((0xB) << ((9-8)*4));
    crh &= ~((0xF) << ((10-8)*4));
    crh |=  ((0x4) << ((10-8)*4));
    GPIOA->CRH = crh;

    /* PB10 TX3 (AF PP), PB11 RX3 (input floating) */
    uint32_t crh_b = GPIOB->CRH;
    crh_b &= ~((0xF) << ((10-8)*4));
    crh_b |=  ((0xB) << ((10-8)*4));
    crh_b &= ~((0xF) << ((11-8)*4));
    crh_b |=  ((0x4) << ((11-8)*4));
    GPIOB->CRH = crh_b;
}

static void uart_setup(USART_TypeDef* U, uint32_t pclk, uint32_t baud, int enable_rx) {
    U->CR1 = 0; U->CR2 = 0; U->CR3 = 0;
    uint32_t div_mantissa = pclk / (16U * baud);
    uint32_t div_frac     = ((pclk % (16U * baud)) * 16U) / (16U * baud);
    U->BRR = (div_mantissa << 4) | (div_frac & 0xF);
    U->CR1 = USART_CR1_TE | USART_CR1_UE;
    if (enable_rx) U->CR1 |= USART_CR1_RE;
}

void uart_init(void) {
    uart_gpio_init();
    uart_setup(USART1, SYS_CORE_CLOCK_HZ,   UART1_BAUD, 1);
    uart_setup(USART3, SYS_CORE_CLOCK_HZ/2, UART3_BAUD, 0); /* TX only */

    /* Enable RX interrupt for USART1 */
    USART1->CR1 |= USART_CR1_RXNEIE;
    NVIC_SetPriority(USART1_IRQn, 10); /* > configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY */
    NVIC_EnableIRQ(USART1_IRQn);

}
#define RX_RB_SZ 256
static volatile uint8_t  rx_rb[RX_RB_SZ];
static volatile uint16_t rx_head = 0, rx_tail = 0;

static inline int rb_pop(uint8_t* out) {
    if (rx_head == rx_tail) return 0;
    *out = rx_rb[rx_tail % RX_RB_SZ];
    rx_tail++;
    return 1;
}
static inline void rb_push(uint8_t b) {
    rx_rb[rx_head % RX_RB_SZ] = b;
    rx_head++;
    /* Nếu tràn, bỏ cũ giữ mới */
    if ((uint16_t)(rx_head - rx_tail) > RX_RB_SZ) {
        rx_tail = rx_head - RX_RB_SZ;
    }
}

/* IRQ: đọc SR rồi DR để clear RXNE/ORE; đẩy vào ring */
void USART1_IRQHandler(void) {
    uint32_t sr = USART1->SR;
    if (sr & (USART_SR_RXNE | USART_SR_ORE)) {
        uint8_t d = (uint8_t)USART1->DR;  /* đọc DR để clear cờ */
        rb_push(d);
    }
    /* (tuỳ chọn) xử lý FE/PE nếu cần */
}
void uart1_write(const uint8_t* p, uint32_t n) {
    for (uint32_t i = 0; i < n; ++i) {
        while (!(USART1->SR & USART_SR_TXE)) {}
        USART1->DR = p[i];
    }
}
void uart1_write_str(const char* s) {
    while (*s) {
        while (!(USART1->SR & USART_SR_TXE)) {}
        USART1->DR = *s++;
    }
}

int uart1_read_byte(uint8_t* out, uint32_t timeout_ms) {
    TickType_t t0 = xTaskGetTickCount();
    TickType_t to = pdMS_TO_TICKS(timeout_ms);
    for (;;) {
        /* lấy từ ring trước */
        if (rb_pop(out)) return 0;
        if ((xTaskGetTickCount() - t0) >= to) return -1;
        vTaskDelay(pdMS_TO_TICKS(1));
    }
}


static void uart3_write_byte(uint8_t b) {
    while (!(USART3->SR & USART_SR_TXE)) {}
    USART3->DR = b;
}
void uart3_write_str(const char* s) {
    while (*s) uart3_write_byte((uint8_t)*s++);
}

void log_printf(const char* fmt, ...) {
    char buf[160];
    va_list ap; va_start(ap, fmt);
    int n = vsnprintf(buf, sizeof(buf), fmt, ap);
    va_end(ap);
    if (n > 0) uart3_write_str(buf);
}


/* ===== CRC16-CCITT (0x1021), init=0xFFFF ===== */
uint16_t crc16_ccitt(const uint8_t* data, uint32_t len) {
    uint16_t crc = 0xFFFF;
    for (uint32_t i=0;i<len;i++) {
        crc ^= (uint16_t)data[i] << 8;
        for (int b=0;b<8;b++) {
            if (crc & 0x8000) crc = (crc << 1) ^ 0x1021;
            else              crc = (crc << 1);
        }
    }
    return crc;
}

/* ====== Metadata helper ====== */
void meta_request_boot(void) {
    bl_meta_t m;
    memcpy(&m, (void*)META_BASE, sizeof(m));
    if (m.magic != META_MAGIC) m.magic = META_MAGIC;
    m.flags |= MF_BOOT_REQ;

    /* Erase + program 1 page (1KB) chứa metadata */
    FLASH->KEYR = 0x45670123; FLASH->KEYR = 0xCDEF89AB;
    /* Erase page */
    FLASH->CR |= FLASH_CR_PER; FLASH->AR = META_BASE; FLASH->CR |= FLASH_CR_STRT;
    while (FLASH->SR & FLASH_SR_BSY) {}
    FLASH->CR &= ~FLASH_CR_PER;
    /* Program halfword */
    FLASH->CR |= FLASH_CR_PG;
    uint16_t* src = (uint16_t*)&m;
    uint16_t* dst = (uint16_t*)META_BASE;
    for (size_t i = 0; i < sizeof(m)/2; i++) {
        dst[i] = src[i];
        while (FLASH->SR & FLASH_SR_BSY) {}
    }
    FLASH->CR &= ~FLASH_CR_PG;
    FLASH->CR |= FLASH_CR_LOCK;
}

/* ====== Tasks ====== */
static QueueHandle_t qh = NULL;

static void blink_task(void* arg) {
    (void)arg;
    for (;;) {
        LED_PORT->ODR ^= (1<<LED_PIN);
        vTaskDelay(pdMS_TO_TICKS(500));
    }
}

static void logger_task(void* arg) {
    (void)arg;
    for (;;) {
        uint32_t tick = (uint32_t)xTaskGetTickCount();
        unsigned hz   = (unsigned)configTICK_RATE_HZ; /* từ FreeRTOSConfig.h */
        log_printf("[APP] tick=%lu tick_hz=%u\n", (unsigned long)tick, hz);
        vTaskDelay(pdMS_TO_TICKS(1000));
    }
}

/* --- Helpers cho parser frame --- */
static int read_exact(uint8_t* buf, uint32_t len, uint32_t per_byte_timeout_ms) {
    for (uint32_t i=0;i<len;i++) {
        if (uart1_read_byte(&buf[i], per_byte_timeout_ms) < 0) return -1;
    }
    return 0;
}
static void send_ack(uint8_t seq) {
    uint8_t a[2] = { ACK_BYTE, seq };
    uart1_write(a, 2);
}
static void send_nack(uint8_t seq) {
    uint8_t a[2] = { NACK_BYTE, seq };
    uart1_write(a, 2);
}

static void uart_cmd_task(void* arg) {
    (void)arg;
    for (;;) {
        uint8_t b;
        /* tìm STX */
        if (uart1_read_byte(&b, 100) == 0) {
            if (b != STX) { vTaskDelay(pdMS_TO_TICKS(1)); continue; }

            /* đọc TYPE, SEQ, LEN */
            uint8_t head[3]; /* TYPE, SEQ, LEN_L (LEN_H đọc riêng để dễ rõ ràng) */
            if (read_exact(head, 3, 50) < 0) { vTaskDelay(pdMS_TO_TICKS(1)); continue; }
            uint8_t type = head[0];
            uint8_t seq  = head[1];
            uint8_t lenL = head[2];
            uint8_t lenH;
            if (read_exact(&lenH, 1, 50) < 0) { vTaskDelay(pdMS_TO_TICKS(1)); continue; }
            uint16_t len = (uint16_t)lenL | ((uint16_t)lenH << 8);

            if (len > 64) { /* App chỉ kỳ vọng LEN nhỏ */
                /* bỏ qua payload + crc16 tương ứng */
                uint8_t drop;
                for (uint16_t i=0;i<len+2;i++) if (uart1_read_byte(&drop, 10) < 0) break;
                vTaskDelay(pdMS_TO_TICKS(1));
                continue;
            }

            uint8_t payload[64];
            if (len && read_exact(payload, len, 200) < 0) { vTaskDelay(pdMS_TO_TICKS(1)); continue; }

            uint8_t c16lsb, c16msb;
            if (read_exact(&c16lsb, 1, 50) < 0 || read_exact(&c16msb, 1, 50) < 0) { vTaskDelay(pdMS_TO_TICKS(1)); continue; }
            uint16_t rx_crc = (uint16_t)c16lsb | ((uint16_t)c16msb << 8);

            /* Tính CRC16 trên [STX..PAYLOAD] */
            uint8_t cbuf[5+64];
            cbuf[0]=STX; cbuf[1]=type; cbuf[2]=seq; cbuf[3]=lenL; cbuf[4]=lenH;
            if (len) memcpy(&cbuf[5], payload, len);
            uint16_t calc = crc16_ccitt(cbuf, 5+len);
            if (calc != rx_crc) {
                send_nack(seq);
                vTaskDelay(pdMS_TO_TICKS(1));
                continue;
            }

            /* Chỉ xử lý TYPE_Q LEN=1 */
            if (type == TYPE_Q && len == 1) {
                uint8_t cmd = payload[0];
                log_printf("[APP] RX Q: cmd=0x%02X seq=%u len=%u\n", cmd, seq, (unsigned)len);
                if (cmd == CMD_BOOT) {
                    /* 2) GỬI ACK và chờ TC => đảm bảo ACK đã ra dây */
                    send_ack(seq);
                    while (!(USART1->SR & USART_SR_TC)) { /* wait TX complete */ }
                    log_printf("[APP] CMD_BOOT -> set BOOT_REQ & reset\n");

                    meta_request_boot();                 /* ghi metadata (mất vài chục ms) */
                    vTaskDelay(pdMS_TO_TICKS(10));       /* đệm tí */
                    NVIC_SystemReset();
                } else {
                    send_ack(seq);
                }
            } else {
                send_nack(seq);
            }
        }
        while (!(USART1->SR & USART_SR_TC)) { /* đảm bảo ACK đã ra dây */ }
        log_printf("[APP] CMD_BOOT -> set BOOT_REQ & reset\n");
        meta_request_boot();
        vTaskDelay(pdMS_TO_TICKS(10));
        NVIC_SystemReset();

    }
}

/* Producer/Consumer queue demo */

static void producer_task(void* arg) {
    (void)arg;
    uint32_t i = 0;
    for (;;) {
        if (qh) xQueueSend(qh, &i, portMAX_DELAY);
        i++;
        vTaskDelay(pdMS_TO_TICKS(200));
    }
}
static void consumer_task(void* arg) {
    (void)arg;
    uint32_t v;
    for (;;) {
        if (qh && xQueueReceive(qh, &v, portMAX_DELAY) == pdTRUE) {
            log_printf("[Q] got %lu\n", (unsigned long)v);
        }
    }
}

/* ====== main() ====== */
int main(void) {
    System_Init();
    relocate_vtor();            // <--- QUAN TRỌNG
    uart_init();

    log_printf("[APP v1] FreeRTOS native (Q/BOOT supported), VTOR=0x%08lX\n", SCB->VTOR);

    /* Queue */
    qh = xQueueCreate(8, sizeof(uint32_t));

    /* Create tasks — nhớ kiểm tra kết quả để bắt lỗi heap */
    if (xTaskCreate(blink_task, "blink", 128, NULL, tskIDLE_PRIORITY + 1, NULL) != pdPASS)
        log_printf("[APP][ERR] xTaskCreate blink failed (heap?)\n");
    if (xTaskCreate(logger_task, "logger", 256, NULL, tskIDLE_PRIORITY + 1, NULL) != pdPASS)
        log_printf("[APP][ERR] xTaskCreate logger failed (heap?)\n");
    if (xTaskCreate(uart_cmd_task, "uart", 256, NULL, tskIDLE_PRIORITY + 2, NULL) != pdPASS)
        log_printf("[APP][ERR] xTaskCreate uart failed (heap?)\n");
    if (xTaskCreate(producer_task, "prod", 128, NULL, tskIDLE_PRIORITY + 1, NULL) != pdPASS)
        log_printf("[APP][ERR] xTaskCreate prod failed (heap?)\n");
    if (xTaskCreate(consumer_task, "cons", 128, NULL, tskIDLE_PRIORITY + 1, NULL) != pdPASS)
        log_printf("[APP][ERR] xTaskCreate cons failed (heap?)\n");

    vTaskStartScheduler();

    /* Nếu tới đây tức scheduler không start được (thiếu heap hoặc VTOR/tick có vấn đề) */
    log_printf("[APP][ERR] vTaskStartScheduler failed — kiểm tra configTOTAL_HEAP_SIZE & VTOR\n");
    for (;;);
}
