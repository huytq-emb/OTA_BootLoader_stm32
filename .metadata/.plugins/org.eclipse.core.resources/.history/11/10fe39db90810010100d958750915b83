#include "boot.h"
#include <stdarg.h>
#include <stdio.h>

#define RB_SIZE 512
static volatile uint8_t rb[RB_SIZE];
static volatile uint16_t rb_head=0, rb_tail=0;

static void rb_push(uint8_t b){
    uint16_t n = (rb_head+1) % RB_SIZE;
    if(n != rb_tail){
        rb[rb_head] = b;
        rb_head = n;
    }
}

static int rb_pop(uint8_t* out){
    if(rb_head == rb_tail) return 0;
    *out = rb[rb_tail];
    rb_tail = (rb_tail+1) % RB_SIZE;
    return 1;
}

void uart1_init(uint32_t baud){
    /* PA9=TX, PA10=RX */
    RCC->APB2ENR |= RCC_APB2ENR_IOPAEN | RCC_APB2ENR_USART1EN | RCC_APB2ENR_AFIOEN;
    /* PA9 AF PP 50MHz, PA10 input floating */
    GPIOA->CRH &= ~((0xF<<(4)) | (0xF<<(8)));
    GPIOA->CRH |=  (0xB<<(4)) | (0x4<<(8));
    /* Baud */
    USART1->BRR = SystemCoreClock/baud;
    USART1->CR1 = USART_CR1_TE | USART_CR1_RE | USART_CR1_UE;
}

void uart2_init(uint32_t baud){
    /* PA2=TX, PA3=RX */
    RCC->APB2ENR |= RCC_APB2ENR_IOPAEN | RCC_APB2ENR_AFIOEN;
    RCC->APB1ENR |= RCC_APB1ENR_USART2EN;
    /* PA2 AF PP, PA3 input floating */
    GPIOA->CRL &= ~((0xF<<(8)) | (0xF<<(12)));
    GPIOA->CRL |=  (0xB<<(8)) | (0x4<<(12));
    USART2->BRR = (SystemCoreClock/2)/baud; /* APB1 = 36MHz default (after SystemInit 72MHz) */
    USART2->CR1 = USART_CR1_TE | USART_CR1_RE | USART_CR1_RXNEIE | USART_CR1_UE;
    NVIC_EnableIRQ(USART2_IRQn);
}

void USART2_IRQHandler(void){
    if(USART2->SR & USART_SR_RXNE){
        uint8_t b = (uint8_t)USART2->DR;
        rb_push(b);
    }
}

void uart1_putc(char c){
    while(!(USART1->SR & USART_SR_TXE));
    USART1->DR = (uint16_t)c;
}

void uart1_write(const char* s){
    while(*s){ uart1_putc(*s++); }
}

void uart1_printf(const char* fmt, ...){
    char buf[256];
    va_list ap; va_start(ap, fmt);
    vsnprintf(buf,sizeof(buf),fmt,ap);
    va_end(ap);
    uart1_write(buf);
}

int uart2_write(const uint8_t* buf, size_t len){
    for(size_t i=0;i<len;i++){
        while(!(USART2->SR & USART_SR_TXE));
        USART2->DR = buf[i];
    }
    return (int)len;
}

int uart2_getc_timeout(uint8_t* out, uint32_t timeout_ms){
    uint32_t t = millis();
    while((millis()-t) < timeout_ms){
        if(rb_pop(out)) return 1;
    }
    return 0;
}

int uart2_read_exact(uint8_t* buf, size_t len, uint32_t timeout_ms){
    uint32_t deadline = millis() + timeout_ms;
    size_t r=0;
    while(r<len){
        uint8_t b;
        if(millis() > deadline) return 0;
        if(rb_pop(&b)){
            buf[r++] = b;
        }
    }
    return 1;
}

/* SysTick for millis */
static volatile uint32_t g_ms=0;
void SysTick_Handler(void){ g_ms++; }
void systick_init(void){
    SysTick->LOAD = SystemCoreClock/1000 - 1;
    SysTick->VAL = 0;
    SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_TICKINT_Msk | SysTick_CTRL_ENABLE_Msk;
}
uint32_t millis(void){ return g_ms; }
