/*
 * main.c â€” Demo Application with CMSIS-OS v1 (FreeRTOS wrapper)
 * - Blink LED PC13
 * - Logger prints system tick/heap
 * - uart_cmd_task listens UART1 (ESP32). If receive BOOT cmd, set boot_request in metadata then reset
 * - Simple producer/consumer queue demo
 */
#include "app.h"
#include "cmsis_os.h"
#include <stdio.h>
#include <string.h>

/* ===== UART low-level ===== */
static void uart_gpio_init(void) {
    RCC->APB2ENR |= RCC_APB2ENR_IOPAEN | RCC_APB2ENR_IOPCEN | RCC_APB2ENR_AFIOEN | RCC_APB2ENR_USART1EN;
    RCC->APB1ENR |= RCC_APB1ENR_USART3EN;

    /* LED PC13 output push-pull */
    GPIOC->CRH &= ~(0xF << ((13-8)*4));
    GPIOC->CRH |=  (0x1 << ((13-8)*4)); /* MODE=01 (10MHz), CNF=00 */

    /* PA9 TX1: AF PP, PA10 RX1: input floating */
    uint32_t crh = GPIOA->CRH;
    crh &= ~((0xF)<<((9-8)*4));
    crh |=  ((0xB)<<((9-8)*4));
    crh &= ~((0xF)<<((10-8)*4));
    crh |=  ((0x4)<<((10-8)*4));
    GPIOA->CRH = crh;

    /* PB10 TX3: AF PP, PB11 RX3: input floating */
    RCC->APB2ENR |= RCC_APB2ENR_IOPBEN;
    uint32_t crh_b = GPIOB->CRH;
    crh_b &= ~((0xF)<<((10-8)*4));
    crh_b |=  ((0xB)<<((10-8)*4));
    crh_b &= ~((0xF)<<((11-8)*4));
    crh_b |=  ((0x4)<<((11-8)*4));
    GPIOB->CRH = crh_b;
}

static void uart_setup(USART_TypeDef* U, uint32_t pclk, uint32_t baud, int tx, int rx) {
    U->CR1 = 0; U->CR2 = 0; U->CR3 = 0;
    uint32_t div_mantissa = pclk / (16U*baud);
    uint32_t div_frac = ((pclk % (16U*baud))*16U)/(16U*baud);
    U->BRR = (div_mantissa<<4)|(div_frac&0xF);
    U->CR1 = USART_CR1_TE | USART_CR1_RE | USART_CR1_UE;
}

void uart_init(void) {
    uart_gpio_init();
    uart_setup(USART1, SYS_CORE_CLOCK_HZ, UART1_BAUD, 9, 10);
    uart_setup(USART3, SYS_CORE_CLOCK_HZ/2, UART3_BAUD, 10, 11);
}

void uart1_write_str(const char* s) {
    while (*s) {
        while (!(USART1->SR & USART_SR_TXE)) {}
        USART1->DR = *s++;
    }
}
int uart1_read_byte(uint8_t* out, uint32_t timeout_ms) {
    uint32_t tick0 = osKernelSysTick();
    while (!(USART1->SR & USART_SR_RXNE)) {
        if ((osKernelSysTick() - tick0) > timeout_ms) return -1;
    }
    *out = USART1->DR;
    return 0;
}
void uart3_write_str(const char* s) {
    while (*s) {
        while (!(USART3->SR & USART_SR_TXE)) {}
        USART3->DR = *s++;
    }
}
void log_printf(const char* fmt, ...) {
    char buf[128];
    va_list ap; va_start(ap, fmt);
    int n = vsnprintf(buf,sizeof(buf),fmt,ap);
    va_end(ap);
    if (n>0) uart3_write_str(buf);
}

/* ===== Tasks ===== */
void blink_task(void const* arg) {
    (void)arg;
    for (;;) {
        LED_PORT->ODR ^= (1<<LED_PIN);
        osDelay(500);
    }
}

void logger_task(void const* arg) {
    (void)arg;
    for (;;) {
        log_printf("[APP] tick=%lu heap free=%u\n",
                   osKernelSysTick(),
                   (unsigned)osKernelSysTickFreq);
        osDelay(1000);
    }
}

void meta_request_boot(void) {
    bl_meta_t m;
    memcpy(&m, (void*)META_BASE, sizeof(m));
    if (m.magic != META_MAGIC) m.magic = META_MAGIC;
    m.flags |= MF_BOOT_REQ;
    /* program flash page (1KB) */
    FLASH->KEYR=0x45670123; FLASH->KEYR=0xCDEF89AB;
    FLASH->CR|=FLASH_CR_PER; FLASH->AR=META_BASE; FLASH->CR|=FLASH_CR_STRT;
    while(FLASH->SR&FLASH_SR_BSY);
    FLASH->CR&=~FLASH_CR_PER;
    FLASH->CR|=FLASH_CR_PG;
    uint16_t* src=(uint16_t*)&m;
    uint16_t* dst=(uint16_t*)META_BASE;
    for(size_t i=0;i<sizeof(m)/2;i++){ dst[i]=src[i]; while(FLASH->SR&FLASH_SR_BSY); }
    FLASH->CR&=~FLASH_CR_PG; FLASH->CR|=FLASH_CR_LOCK;
}

void uart_cmd_task(void const* arg) {
    (void)arg;
    for (;;) {
        uint8_t b;
        if (uart1_read_byte(&b, 100) == 0) {
            if (b == 'B') { /* simple: if 'B', request bootloader */
                log_printf("[APP] BOOT cmd received -> request BL\n");
                meta_request_boot();
                NVIC_SystemReset();
            }
        }
        osDelay(10);
    }
}

/* Producer/consumer demo */
static osMessageQId qid;
void producer_task(void const* arg) {
    (void)arg;
    for (int i=0;;i++) {
        osMessagePut(qid, i, osWaitForever);
        osDelay(200);
    }
}
void consumer_task(void const* arg) {
    (void)arg;
    for (;;) {
        osEvent e = osMessageGet(qid, osWaitForever);
        if (e.status == osEventMessage) {
            log_printf("[Q] got %ld\n", e.value.v);
        }
    }
}

/* ===== Main entry ===== */
int main(void) {
    SystemInit();
    uart_init();

    log_printf("[APP v2] running, VTOR=0x%08lX\n", SCB->VTOR);

    osKernelInitialize();
    osThreadDef(blink, blink_task, osPriorityNormal, 0, 128);
    osThreadDef(logg, logger_task, osPriorityLow, 0, 256);
    osThreadDef(cmd, uart_cmd_task, osPriorityAboveNormal, 0, 256);
    osThreadDef(prod, producer_task, osPriorityBelowNormal, 0, 128);
    osThreadDef(cons, consumer_task, osPriorityBelowNormal, 0, 128);
    osMessageQDef(myq, 8, uint32_t);
    qid = osMessageCreate(osMessageQ(myq), NULL);

    osThreadCreate(osThread(blink), NULL);
    osThreadCreate(osThread(logg), NULL);
    osThreadCreate(osThread(cmd), NULL);
    osThreadCreate(osThread(prod), NULL);
    osThreadCreate(osThread(cons), NULL);

    osKernelStart();
    for (;;);
}
